---
title: "Git Basic"
subtitle: "Hamid Semiyari"
date: "`r Sys.Date()`"
output:  
  html_document:
    toc: true
    toc_depth: 4
    toc_float: false
    highlight: pygments
urlcolor: "blue"
---

# GIT COMMANDS

-   How to take snapshots of our project?

1.  Create a directory for our project. So Let us create a directory called `Hamid`\
    You need to type
    -   `mkdir Hamid` , where `mkdir` means "Make Directory" and go to this directory.
    -   `cd Hamid`, where `cd` stands for "Change Directory". Now we can have our files in it.
2.  We want add files to a Git repository. We have to initialize a new empty repository.
    -   So we type `git init`
    -   The `git init` is a one-time command you use during the initial setup of a new repo. Executing this command will create a new `. git` subdirectory in your current working directory.

Now we have initialized empty Git repository in our directory.\
Inside of our directory we have a sub directory called `.git`. By default this sub directory is hidden because you are not suppose to touch it.\
Type `ls` it will provide all files and sub directories in your directory. You don't see anything. We have not add any file yet and the sub directory `.git` is hidden.\

If you type `ls -a` where "a" is short for "all", you will all files as well as the `.git` sub directory.

-   Windows: You can open this with windows explorer or file explorer. Type `start .git`

-   Mac: You can open this with "finder". Type `open .git`

-   Linux: Tupe `xdg-open .git`

This is where stored information about our project history. So, we have directories like hooks, info, objects and references. This is how git stores information. That is why this directory is hidden. If you remove or crop this directory you are going to lose your project history. If you type `rm -rf .git` Now you do not have a git repository anymore. Since we have removed it we need to initialize it again. `git init`\

-   `ls` it will provide list of all visible files and sub directories in your directory\

-   `ls -a` It will provide all files as well as hidden\

-   `ls -la` It will provide all files indirectory that start with dot\

-   We have created our first git project and we initialized it and we saw that it created a `.git` directory inside of our folder (directory). 

-   **Dot files are invisible file.** How to look at inside of `.git`? Type `ls -la .git`\
    The result of these code gives us all the files that Git using to do the all the tracking. We are not using any of these files except `config` file. Type `cat .git/config`, where cat is short for concatenation and `.git/config` shows you the content of the file.\
    Once again if you remove or delete `.git` Git will be removed from the project. It will no longer tracking. There will be no tracking information left anywhere on your hard drive.\
    Now we need to talk about basic Git WorkFlow

## GIT WORKFLOW

### THE THREE TREES

Lots of other version controls are Two Trees architecture. "Working Directory" and "Repository". Git has Three Trees. "Working Directory", "Staging Area, or Index" and "Repository."

-   Imagine we have a file "A" in the "working directory" ($v_1$). We use `git add` command to move it to the "staging directory". Now we use `git  commit` to push itto the "repository".\
    Now repository have the same file and it is the same version as it is in our staging directory and working directory.
-   Now we have done some changes to "A". Let us called it "B"., now in working directory we have "B" ($v_2$). Let us adding it to the staging index and push it to the repository.\
-   Now the repository has two set of changes set "A" and "B".\
-   The same process, Let us we do some changes in working directory and have file "C" ($v_3$). These are typical workflow, we are going to be using to make `commits`. You may use `git log` to view those commands. To see what was the changes between each one.
-   Git does not store duplicate content and also it compresses the content. So, it does not take as much as store you may think.

## HASH VALUES

We have shown each changes with "A" and "B" and "C".\

-   Git generates a "Checksum" for each change set.

-   Checksum is a number that is generated by taking data and feeding it into a mathematical algorithm. So, the checksum converts data into a simple number. **Same data always equal to the same checksum**.\

-   The checksum is used to guarantee the data integrity.\

-   The Data Integrity is the fundamentally built-into git.\

-   So, each "HASH value" is unique and directly tied to the contents that are inside of it.\

-   The algorithm that git is uses is "SHA-1" (HASH algorithm).\

-   Git also does something else with data integrity. In addition to use the code in each of snapshots (A, B, and C). It also uses "Metadata". That means you CAN NOT change the commit message or commit author or parent of the commit without changing its SHA value.

### EXAMPLE

Let us add a cople of files to our project. We use a standard unix command called `echo`. We use it to write a content to a file. Let us write "hello".\

-   Type `echo hello > file1.txt`. where 'echo' means to write "hello" and `>` means "to" the file "file1.txt".

-   Type `echo hello > file2.txt`.

    -   Please note that, git does not automatically track your files so we have to instruct git to track them.\
    -   Working Directory is the only Tree in git architecture that does not require a git command to move file changes to that tree.

-   Type `git status` to get the status of **Working directory**. "Working Tree is clean"means working tree is matches with what in repository.

    -   files are in **on branch master**

    -   **No Commit** yet

    -   We see that both of these files are in red font. which means they are not tracked yet.

    -   They are not on the **staging area**. So, we need to type

        -   `git add file1.txt` one by one or we can have multiple file separated by space\

        -   `git add file1.txt file2.txt`.\

        -   We may use `git add .` this stage **all** files ( that are not in the `.gitignore`) in the entire repository. We have to becareful with that because there might be files that you do not want to your repository.\

        -   We also can use patterns such as `git add *.txt`. It will stage all files that have extension txt.

    If you type `git status` you will see those two files now in green. Which it means they are in the staging index.\

### EDIT FILES

If we edit a file and type `git status`. We get a message like\
**Changes not staged for commit:**\
**( SOMETHING WRITTEN HERE )**\
**( SOMETHING WRITTEN HERE )**\
**midified: \[name of the file modified in red font\]**

The process of adding an edited file is exactly same as adding a new file.

Let us modify the file1.txt. Type `echo  world >> file1.txt` where `>>` means "append" (add as an attachment or supplement). Now let us run `git status`. It shows we have to tracked files (in the staging area) and one modified in working directory file. We have file1 in the staging area but we have modified the file1 and the modified or second version of file is in the working directory. So there are some changes that are not staged yet. We need to run `git add file1.txt` now look at the status of our working directory. Both of these files are in the staging area. And we don't have any unstated changes.

### COMMIT

-   How to commit the snapshots in our stageing area to permanently store in our repository?\
    Type `git commit -m "YOUR MESSAGE"`. Where `-m` is for the message. A short message that identifies what this snapshot represents. For instance `git commit -m "Initial commit`.  Sometimes a short message is not enough for instance we were working on a bug and we want to explain about something, in this case just type `git commit`. After you enter a VScode will be open.\
    \
    Now you find edit the file **COMMIT_EDITMSG** (it is the name of VSCode). On the top you can type a short description (less than 80 character). After that we have a line break (skip a line) and after that we have the long description. Now we save the changes and close the VSCode (by clicking x on top) and back to our terminal and you will see its says the message and how many files has been changes and so on.\
    **NOTE**\

-   Comments should not be too big or too small.\

-   We don't want to make commit every time we update a file. In other hand we don't want to code for a couple of days and then make a commit. The whole point of commiting is to record checkpoints as we go. So, if we messed up we always can go back and recover our code. So based on the project your time you spend on your code, you may want to commit. If you work all day, then you may want to commit 5 to 10 times a day.\

-   As you reach a state that you want to record then make a commit.\

-   Do not mix the commits. If you are working on a code and fixing a typo and bug. Then you should have two commits one for the bug and one for the typo.\

-   Use present tense in the commit messages. Instead of saying Fixed the bug, you should say Fix the bug. If you want to use past tense it is fine but make sure you and other team members are use this one.

-   **Question** Can we skip the staging area? or do we have to stage our changes before commiting them?\
    The answer is no, but you should know what you are doing. Please note that the whole point of staging area is, if there is changes that need to be reviewed. If you are 100% sure that the changes don't need to be review so you can skip it.\

-   **Question** How to skip staging area?\
    Let us go over it by an example. Type `echo test >> file1.txt`\

    -   We now skip the `git add` because we are not putting anything in staging area
    -   Type `git commit -a -m "Right Your Message here"` where `-a` is for all.
    -   We also can combine both `-a` and `-m` together and write `git commit -am "Type Your message"`
    -   If you look at the message it will tell you how many files was changed and how many insertion we had. If we have lines deleted then we had deletion\

    **What are "insertion" and "deletion"?**\
    Insertion is the number of lines inserted and deletion is the number of line deleted.

### HEAD POINTER

-   *Head* is a reference variable. We call this variable a pointer because its purpose is to reference or point to specific commands to a repository. As you make new comment the pointer changes or move to a new comment.\

-   The *Head* always point to the current branch of our repository. Imagine we have 3 versions of a file with commit. Head will point to the last commits that we make. It is the *parent* of the next commit that we make.

-   Head becomes more important when we start talking about *branches*. By default the branches that we are working is called *master* (or sometimes *main*) branch.

-   If we make a new branch then header moves to commit on this branch.

-   We have ability to move Head back and forth to different branches, so we can write on different branches.

-   Git will keep track of moving the Head around for you.

-   Remember inside of our project folder we have a directory called `.git` and inside of `.git` we have *Head*

    -   Type `ls -la .git`
    -   To see what is inside of file *Head*, type `cat .git/HEAD`. It returns something like "ref:refs/heads/master"
    -   Type `git log`\
        It will provides all changes, commits, authors, and more. You also see that the pointer (HEAD) is pointingthe SHA value to the master branch.

### REMOVE FILE

Let us say that we do not need the "file2.txt" any longer. We use `rm` command to remove the file. This command is a **UNIX** command.\
- Type `rm file2.txt`\

-   Let us now run the `git status`. It shows that we have one change that is not stage for commit. (Not in staging area). So the file is removed from working directory but still is in staging area. To see this type

    -   `git ls-files`. These are the files in staging area and you will see that the both files are there.
    -   Remember whenever we make a changes to a file we have to stage the changes by `git add` command. Now we have to do that here.\
    -   Type again `git add file2.txt` Now we have report what we have done in working directory and updated the stage area.\
    -   Type `git ls-files` and you will see the "file2.txt" is not in the staging area any longer.\
    -   Type `git status` you will see you have one change ready to be committed and indicated with green font "deleted file2.txt" that means the change is in the staging area and ready to be committed.
    -   Type `git commit -m "Remove unused code"`. Now you see in terminal that one file is changed and one is deleted.

    **Question:**\
    Is there any way we can do both these command only with one command?\
    Instead of using `rm FILE_NAME.txt` and `git add FILENAME.txt` to remove the unwanted file from both directory and staging area. We can use `git rm` command instead of `rm` UNIX command, so if you type\

    -   `git rm FILENAME.txt` or if you have multiple files you can type
    -   `git rm FILENAME1.txt FILENAME2.txt` or you can use a pattern
    -   `git rm *.txt` or whatever the extension of the file is!

### RENAMING or MOVING FILES

-   Currently we have "file1.txt. in our working directory. We want to rename to"main.js". We will use the `mv` command (move from UNIX) to rename file1.txt.\
    -   Type `mv file1.txt main.js`. Then type `git status` Now we see we have to changes and both of them are unstaged because they are indicated by red font. We have deleted operation "deleted: file1.txt" and we have a new untracked file "main.js".
    -   As you know by now, git doesn't automatically track all your files everytime you have a new file in your project. You have to add it to staging area so git starts tracking it. So, we have to use `git add` command to stage both these changes.
    -   Type `git add file1.txt` and `git main.js` or you can type `git add file1.txt main.js`
    -   Now you need to type `git status`. You will see both files are green which means both are in staging area. Also git recognize that we have renamed file1.txt to main.js. If you look at the terminal you will see "renamed: file1.txt -\> main.js"
    -   So renaming or moving files is a two-step operations. First we have to rename or remove the file from working directory and then we need to stage two types of changes addition and deletion. So, similar to *removing* file, git gives us special command to do both step in one. It is `git mv`. Note \`git mv OLD-File NEW-File.
    -   Type `git mv main.js file1.js`. Now if you type `git status` you will see the change has applied to both working directory and staging area. Now let us commit the changes type `git commit -m "Refactor code"` Look at the *statistics* one file was change with 0 insertion (we didn't add any new lines to any files) and 0 deletion (we haven't remove any lines from any files)

### IGNORING FILES

Almost in every project we have to tell git ignore a certain files and directories. For instance, we don't want to include log files or binary files. These files are generates as a result of **compiling** our code. Adding these files just increases the size of our repository without adding any valuable information. Let us create a new directory called **logs**. - Create **logs** directory. - Type `mkdir logs` and then add a log file here, by - `echo hello > logs/dev.log`. Now let us get the status - `git status`. Now git saying that we have an untracked directory called logs. **But we don't want to add this into staging area** Because we don't want to git to track this. So to prevent this we have to create a special file called `.gitignore`.\

-   Create **`.gitignore`**. This fies has no name just has an extension. It should be in root of your project. So, type
    -   `echo logs/ > .gitignore`. Now we need to open file using VSCode/
    -   Type `code .gitignore` So in this file we have a single entry "logs/". Which indicates a directory. We can list as many files and directory as we want here for example we can include "main.log". We can also use pattern like `*log` (all log files).\
        -   In the VSCode underneath of "logs/" type "main.log" and underneath of this one you can write "\*.log"
    -   Once we are done we save the changes and back to terminal. Now run\
    -   `git status`. You will see that git no longer says that we have a new directory called logs because it is **ignoring it**. Instead it says, we have a **new file** and it called **.gitignore**. Now let's add this file to staging area and commit our code\
    -   Type `git add .gitignore` and `git commit -m "Adding gitignore"`.
-   So this is how git ignores a file or directory. But remember, it works if you have not already included a file or directory in you repository. If you have files added before creating `.gitignore`, those file will stay in your repository.
-   Let me show you what happen in this case by an example. Let us create a new directory called **bin**. Imagine this directory has our compile source code so using the echo command `bin/app.bin`. And we are going to accidently include this to our repository before creat the ignore file.\
    -   `mkdir bin`

    -   `echo hello > bin/app.bin`

    -   `git status` Now we have anew directory and we want accidentally commit it to our repository

    -   `git add .` Remember `.` means add all the changes

    -   `git commit -m "Add bin."`. Here is one problem, every time we **compile** our code git is going to say that the file "bin.app.bin" is changed. (Remember any code your compile its bin will change). Thus we have to stage and commit it.

    -   Back to file ".gitignore" we need to **add "bin/"** save it and back to terminal.

    -   How to go to ".gitignore" file? You can directly open it or type code\
        `code .gitignore` on terminal.

    -   `git status`, you will see you have modified ".gitignore". (remember we added "bin/"). Now let us stage and commit it.

    -   `git add .`

    -   `git commit -m "Include bin/ in gitignore."`. This time git is not going to ignore changes in this directory. Because it's already tracking this directory. So Let us modify our bin file by saying

    -   `echo hello world > bin/app.bin` look at status

    -   `git status`. Git says the file is modified. This is not what we want. We want this file to be ignored. Now we want to remove this file from staging area. Which we are what proposing for the next commit.

    -   The command `git ls-files` shows the files in staging area. As you see the **bin** file (or directory) is in staging area. We should remove it. With remove command (`git rm`) we can remove a file from both working directory and staging area. But in this case **we don't want to remove it from working directory**. Why? because this is how we launch our application. So we want to remove it **only from staging area.** How?  By using "options" for `git rm [option]` command.

        -   Option: `--cached` We can remove only from the index (or staging area. Index is the old term for staging area).\
        -   Option: `-r` allow recursive removal

        (You can find more help about `git rm` command by typing `git rm -h`, where `-h` means for help. )

        -   

            ```         
            `git rm --cached bin/` 
            ```

            If you just type only option `--cached`. You will get error " fatal: not removing 'bin/' recursively without -r". Thus you need to type\
            `git rm --cached -r bin/`. Now the entire directory will be removed from staging area. To verify just type

        -   `git ls-files` and you will say the directory bin is not there.

        -   `git status` We have one change that is ready to commit. The directory is deleted from staging area.

        -   `git commit -m "Remove the bin directory that accidentally was committed"` From now on git will not track changes from this directory. So if we type

        -   `echo test > bin/app.bin` and then `git status` we see nothing to commit and working tree is clean.

        **If you go to *github.com/github/gitignore* you can see various "gitignore" template for different programming lnguage. For R is the file "R.gitignore".**

### SHORT STATUS

The command `git status -s` provides you with a short status. The modified file will be shown by red font capital M and untracked by ?? in red font. For instance if you run `git status` and you have "Modified: file1.js" and "untracked files: file2.js". If you run `git status -s` you will get "M files1.js" and "?? file2.js" The green A means the file is added and green M means the modified file is added.  - You may want to look at `git status -h`. For instance you will see that `git status -b` gives you information about branch.

-   Let us have an example.We are going to modify one file and add a new file
    -   `echo sky >> file1.js` We are appending sky to the file. Let's create anew file
    -   `echo sky >  file2.js`. Now lwt us run the status
    -   `git status`, it shows we have one modified file and one new file. The outout is very comperhancive but very wordy.
    -   `git status -s`. It looks much better. We have two columns. The **left column** represent the **staging area** and the **right column** represents the **working directory**.
        -   We have modified file1, we have some changes but this changes are not in the staging area. It is in the working directory and we don't have it in staging area. That is why the left column is empty and we have a red M in the second column,
        -   (Second row) we have two red question marks in both columns.
    -   Now let add file1 to staging area `git add file1.js`. Now run another short status
        -   `git status -s`. Now for file1 we have a green M in the left column or in the staging area column. On the right column we don't have anything. Why? Because we don't have any extra changes. What happen if we modified file1 another time?
        -   `echo ocean >> file1.js` and the run the short status `git status -s`. Now in the lef column we green M, which means we have some changes in the staging area, We also have a red M in the working directory column which indicates we have some changes in the working directory tha are not added to the staging area. Now let us
        -   `git add file1.js` and then `git status -s`. Now, we haveonly one green M in the staging area column, It means all changes we have in working directory are in the staging area.
    -   Now let us add file2 to staging area and then run short status
        -   `git add file2.js` and then `git status -s`. Now we see that in staging column we have Green M for file1 which indicated is modified and we have Green A for file2 which indicates it is added. If we delete a file it will be denoted by **D**.

### VIEWING STAGED AND UNSTAGED CHANGES

Before we committing what we have in the staging area we need to **review our code** because we don't want to commit bad or broken code to our repository.\

-   **Question** the `status` command shows that the files that have been affected. How can we see the exact lines of code that we have staged? We need to use `diff` command.
    -   `git diff --staged`. Now we see what we have in staging area. Comparing files using terminal widow is not really the best wey to do it. It is better to use *Visual Tools*. Let us now explain the output of this command and then we show how to do it by a visual tool.
    -   At the top you see the diff utility was called. Something\
        like *diff --git a/file1.js b/file1.js*   So we are comparing two copiestwo copies of the same file. The first copy *a/file1.js* is the old one. Which we had in the last commit. and the second copy *b/file1.js* is what we currently have in the staging area.
    -   Below that we have *index ...*, which is some metadata and it doesn't matter.
    -   Next we have the "legend". So changes in the old copy are indicated by a **Minus (-)** sign and changes in the new copy indicated by **plus (+)** sign. -Now we have "header" with some information about what part of our file has changed. Our file is very short and we have only a few lines of text. In reality the files can have hundred lines of code. In this case git divide them into chunks and every chunk has header with some information. Here we have only one chunk and one header. We have two segments
        -   The first segment is *prefix with a minus sign* gives us information about old copy and the second segment is a *prefix with a + sign* this contains information about new copy, which is what we have in staging area. For instance the header is\
            *\@\@ -1,3 +1,5 \@@*\
            *hello*\
            *world*\
            *test*\
            *+sky*\
            *+ocean\*\

            -   So old copy start from 1 and 3 lines have been extracted *-1,3*\
                *hello*\
                *world*\
                *test*\
            -   New copy start from 1 and 5 lines have been extracted So old copy start from 1 and 3 lines have been extracted *+1,5*\
                *hello*\
                *world*\
                *test*\
                *+sky*\
                *+ocean*\
                You see these two lines with + sign (*+sky*, *+ocean*) are thelines that we have added in the new copy. They are green which means they are new lines.
    -   After that we see that diff utility is comapring two file of file2 and the explanation is exactly the same. But if you look at the legend see we had no old file because it was a new file. So, in the last commit we didn't have a file called file2.js. 
        -   *\@\@ -0,0 +1 \@@*\
            *+sky\*\
        -   That is why in this header we have\
            *-0,0* starting from line 0 we have 0 line extracted because there was no old copy of this.\
-   **Question:** How to see the changes in the working directory that are not staged yet? Run diff without any argument.\
    -   `git diff` You will see no output here. Why? because we have staged all changes in our working directory. We can verify this with short status command. `git status -s`. You will see Green M and A.\
        -   Example: Let us make a changes to file1.\
            -   `code file1.js` It will open the file with VSCode. Let us change the first line to hello world. Now wsave it and get back to terminal. Now run a short status\
            -   `git staus -s` For file1 we see we have some changes in the working directory that are not in the staging area. Let us look at this changes with diff command without any argument\
                -`git diff`. So we are comapring two copies of file1. The old copy is what we have in the working directory. Take a look at old copy. We have the line `-hello` in red which is removed and in the new copy which is what we have in the working directory, we have `+ hello world` in green (new line). 
                -   If we run **`git diff`** we will see unstaged changes 
                -   If we run **`git diff --staged`** we will see staged changes that are going to go in the next commit.

### VISUAL DIFF TOOLS

-   We use visual tools to easily compare files. If you have noticed that we are going to use `VSCode` because it can be run in both Windows and Mac. We need to tell git that we are going to use VSCode as a default diff tool.
    -   `git config --global diff.tool vscode`. Then we want to tell how to lunch VSCode.
    -   `git config --global difftool.vscode.cmd "code --wait --diff $LOCAL $REMOTE"`.\
        We are going to lunch `code` with few arguments
        -   `--wait` It tells terminal window wait until we are done with VSCode
        -   `--diff` it tells VSCode that we want to use it for the `diff` command
        -   `$LOCAL` and `$REMOTE` are place holder for old and new copies of the file. So let us to see we got everything right\
    -   `git config --global -e` With this command we want to **edit our global configuration setting** in our default editor which is VSCode. So we want to take a look to see if everything installed.
    -   The file `.gitignore` will be open (VSCode). scroll down to see everything is installed. It is possible in the last line the two `$` sign argumnets are missing so you just eneter them\
        *cmd = "code --wait --diff"*\
        *cmd = "code --wait --diff \$LOCAL \$REMOTE"*.\
        Make sure get this right otherwise it wont work correctly. Let's save and close the VSCode and back to terminal.\
    -   Now we want to use `diff` command but we want to use visual tool so we use `difftool`.\
        -   `git --difftool` If we want to see unstaged changes\
        -   `git difftool --staged` If we want to see staged changes that are going to go in the next commit.\
            -In terminal type `git difftool`. The output says something like \*Viewing (1/1): 'file1.js, which indicates we have modified only one file. a prompt ask you\* Launch 'vscode' \[y/n\]? 
            -   Go ahead and type `y` in terminal. There is old copy which is whar we have in the working directory as you can see we can easily tell the line in the left has been replaced with one in the right. It is much easier to see the changes. Let us close the window and back to the terminal and look at the staged changes.\
            -   `git difftool --staged`It will show to file has been affected. The output says something like *Viewing (1/2):'file1.js'* The first file is `file1.js`. A prompt ask you *Launch 'vscode' \[y/n\]?* click `y`. and you will see the changes in the last command (left collumn) and in the staging area (right column). Let us close it and back to terminal.Then you get *Viewing (2/2):'file2.js'* and *Launch 'vscode' \[y/n\]?* click `y` to see for the second file. Remeber this file was a new file and it had no old file.

### VIEWING THE HISTORY

We have made a few comments but where are there. How to get them? - Type `git log` to look at the history. It gives all the commits that we have created **sorted from latest to earlist**. Each commit has a unique identifier or HASH (a 40 character hexadecimal string) that git generated automatically. The latest commit has a head pointer to master branch **HEAD -\> master**, it tells what branch we are currently working. The next line we get the **Author** and the **Date** and the time the commit was created. - use *SPACE KEY* on your keybord to go to the next page and - use *q* to quit - To learnmore about log command use `git log -h` - `git log --oneline` shows us a short summary - `git log --oneline --reverse` it will reverse the order

### VIEWING A COMMIT

-   **Question:** How to see what we have exactly changed in a given commit? Then the question is how to refernce the commit that we are interested? There are two ways.

    1.  Use its unique identifer number (HASH). You do not need to write the entire number, just a few is enough as long as type enough so it reflects only that commit (not overlapped with any commit's HASH number)

    -   `git show d601b90` *NOTE: The number I eneterd is just a made up number here. You should look at your commit's number*

    2.  You may use the *HEAD*

    -   `git show HEAD` It will gives you the info of the latest commit.
    -   `git show HEAD~1` it gives you the commit before the last one
    -   To go back 3 step back we type `git show HEAD~3`. -It will gives us info about the date of commit, the author, message about a diff that what has been changed and so on

-   **Question** W\]What we need to do if we do not want to see the differences, we just want to see the final version that is stored.

-   Type `git show HEAD~1: .gitignore` It will gives you the exact version stored in this commit. You mayget something like

    -   `logs/`
    -   `main.log`
    -   `*.log`
    -   `bin/`

-   Remember, each commit contains a complete snapshot of aworking directory. Not just changes. The `git show` gives you only the differences. Type `git show HEAD`. **What if we want to see all the files and directories in a commit?** We need to use the *TREE* command.'

    -   *tree* is a data structure for representing *hierarchical*information. In a tree we have *nodes* and nodes can have *childeren*. These childrens cn be files and other subdirectories/
        -   Type `git ls-tree HEAD~1`. Now you get all the files and directories stored in this commit. the output is the unique identifier and the file and/or tree. Look at the second column, you'll see that *file* represent by *blob* and *directories* represent by *tree*.For instance, the *.gitignore* is a *file or blob* and *bin* is a *tree*./
            -   If yo use show command and use the unique identifier if the file or directory, it will return the files that you have in that file. For instance if you use the unique identifier of `.gitignore`
            -   `git show 1dcc30` then the content of the `.gitignore` file are:
                -   `logs/`
                -   `main.log`
                -   `*.log`
                -   `bin/`

### UNSTAGING FILES

-   As you have learned we always must review the stuff that we have in the staging area before we making a commit. Run status/

    -   `git status -s`the output shows a **green M in the staging column**.We reviewed these changes and we realized that the changes in the file1 shouldn't go to the next commit. Perhaps because of these changes are logically part of different task.So we want to *undo* the `add` operation. Because earlier we used `add` command to add addfile1 to the staging area. Now we want to *undo* this operation. We will use the `restore` command. Make sure you have version 2.28 or hire, otherwise this command won,t work./

        -   Note; used to we do reset command and many people find it hard to work. so we are not using it any longer/
        -   Type `git version` or `git --version` to see what is the version of your git./

    -   We want to restore file1 in the staging area so type

        -   `git restore --staged file1.js` . You can type multiple file
        -   `git restore --staged file1.js file2.js`. You also can use a pattern
        -   `git restore --staged *.js`

    -   But we want to restore only file1 so type `git restore --staged file1.js`. If you runs short status, then you will not see a **Green M is the staging column**. Because all the changes we had in the staging area now they are in the working directory.

    -   **Question:** How the `restore` command works? It takes all the copy from the next environment. What is the next environment for staging environment? It is the repository. So when we restored file1 in the staging area git took the last copy of this file from last snapshot and put it in the staging area.

    -   **Question:** what happen if we restore file 2? If you look at the short status, you'll see the *GREEN A* which is short for added to the staging area. This is a new file in the staging area. Since this file is new, it does not exist in the *last commit*. When we *restore* this file, git is going to remove it from the staging area and take it back in its previous state which is a new untracked file.

        -   Type `git restore --staged file2.js` and then run `git status -s`. You will see both staging column and working directory columnhave `?` for the file2.js.

### DISGARDING LOCAL CHANGE

-   There are times that we have some code in our working directory that we want to throw away. For instance, there are some local changes in the file1.js. **How we can udo these changes?** to undo thses changes we use `restore` command.
    -   Type `git restore file1.js`when we run this command git is going to take the version of this file in the next environment which is the staging environment and copy it to working directory.
        -   `git restore .` This **undo all the local changes**. If you run `git restore .` we expect all files to be removed, but if you run short status, you will see still file2 is till there. Why? so file2 is new and **UNTRACKED** file. So, git hasn't been tracking this file. So, when we tell git to restore this file, git doesn't know where to get a previous version of this file. The previous version doesn't exist in our staging environment or in our repository. **HOW to remove untracked file?**
        -   Type `git clean`. The output of this file is a **FATAL** warning, git tells us this is a dangerous opeation if you accidentally remove these untracked files there is no way you can recover them. We want to remove the `file2`, but git refuse to do that. What do we need to do?
            -   Take a look at the clean help file. so type `git ckean -h`. You will see the option `-f` **force** git to remove this untracked file. And -d for removing the whole directories So you need to type
            -   `git clean -fd` then type `git status -s` you see it's been removed.

### RESTORING A FILE TO AN EARLIER VERSION

-   You know, once git tracked a file, it stores every version of that file in its database and that means if you screw things, you can always restore a file or a directory to a previous version.

    -   Let us delete the file one. Type `git rm file1.js` The command `git rm` remove the file from both the working directory and staging area.
    -   Type `git stats -s` the output shows **Green D** in the first column.
    -   Commit delete the file \`git commit -m "Delete file1.js" Now we just realized we should not do that. - We want to **restore**, so let's look at the history - `git log --oneline`, We want to restore file1 to the commit before the last commit. (NOTE: You may want to look at `git restore -h`)\
        - Type `git restore --source=HEAD~1 file1.js` Now, if you run the short status,/ - `git status -s` it tells you have a new untracked file
testing
